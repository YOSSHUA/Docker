# Docker reference

# Terminology


## Container

<br>

A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. To see all the containers in your machine type `docker container ls`.

<br>

## Container image

<br>

It is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. To list all the images in your machine type `docker images`.


Container images become containers at runtime.

<br>

## Dockerfile

<br>

It's simply a text-based script of instructions that is used to create a container image. Example of a simple image:

```docker
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```
Each instruction creates one layer:

- `FROM` creates a layer from the ubuntu:18.04 Docker image.
- `COPY` adds files from your Docker client’s current directory.
- `RUN` builds your application with make.
- `CMD` is the default command to run when starting a container from this image.

<br>

### Building the container image

<br>

We will use the following command in the terminal to build the image container with the Dockerfile:
```
docker build -t <image-name> .
```

- `-t` flag tags our image as `ìmage-name`.
- The . at the end of the docker build command tells that Docker should look for the Dockerfile in the current directory.

<br>

### Run a container given certain image container

<br>

```
docker run -d -p <host port>:<container port> <image-name>
```

* `-d` run the container in detached mode(in the background)
* `-p <host-port>:<container-port>` map the host port to the container port
* `<image-name>` is the image to use

<br>

### Checking status of containers running

<br>

The command  `docker ps` shows the information of our container running.

<br>

### Stop the container

<br>

To stop the container type `docker stop <container-id>`. The ID is shown with `docker ps`.

<br>

### Execute command in the container

<br>

To execute a command in the container's shell you should run the following command
```
docker exec <container-id> <YOUR-COMMAND>
```

<br>



# Manage data in Docker

<br>

By default all files created inside a container are stored on a writable container layer. This means that:

- The data doesn’t persist when that container no longer exists, and it can be difficult to get the data out of the container if another process needs it.

Docker has two options for containers to store files in the host machine, so that the files are persisted even after the container stops: volumes, and bind mounts. 

<br>

## Container volumes

<br>

File systems mounted on Docker containers to preserve data generated by the running container. To list all the volumes type `docker volume ls`.
<br>

### Create volume
<br>

To create a volume type `docker volume create <volume-name>`

<br>

### See volume information
<br>

To see the relevant information of your volume you have to run `docker volume inspect <volume-name>`.

<br>

### Delete volume

<br>

To create a volume type `docker volume prune <volume-name>`

<br>

### Attach volume to container

<br>

To acces files in volume within the container you should run the following command: 

```docker run -dp <host port>:<container port> -v <volume-name>:<path-in-container> <image-name>```

<br>

### See container logs

<br>

To see the logs of a given container, run the following command: 

```docker logs <container-id>```

<br>


## Bind mounts

<br>

File or folder stored anywhere on the container host filesystem, the bind mount is mounted into a running container. We can use a bind mount to mount our source code into the container to let it see code changes, respond, and let us see the changes right away.
To mount it you should type ```docker run -dp <host port>:<container port> -v <path-in-host>:<path-in-container> <image-name>```

-  `-v` flag to specify a volume mount. We will mount the volume in `<path-in-container>`, which will capture all files created at the path.


<br>

Comparison between Named volumes and Bind mounts

![Volumes](https://github.com/YOSSHUA/Docker/blob/main/Images/volumeTypes.PNG?raw=true)


# Networking 

By default containers run in isolation and don't know anything about other processes or containers on the same machine. The only rule is 

**If two containers are on the same network, they can talk each other. If they aren't, they can't.**

<br>

### Create network

<br>

To create a network type the following command ```docker network create <network-name>``` 

<br>

### Connect container to a network

<br>

To connect a container to a network during start type ```docker run -d --network <network-name> --network-alias <container-alias-in-network> <image-name>```


# MySQL in Docker containers

To start a MySQL container and attach it to a network in such a way that other containers are able to connect to it we have to type the following command:

```docker run -d --network  <network-name> --network-alias <container-alias-in-network> -v <volume-name>:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=<mysql-password> -e MYSQL_DATABASE=<db-name> <mysql:version>```

Possible environment variables to specify MySQL connection settings. They are the following:

- ```MYSQL_HOST``` - the hostname for the running MySQL server
- ```MYSQL_USER``` - the username to use for the connection
- ```MYSQL_PASSWORD``` - the password to use for the connection
- ```MYSQL_DB``` - the database to use once connected

You should avoid typing the information directly. Instead use env var with a ```_FILE``` suffix to point to a file containing the variable. As an example, setting the MYSQL_PASSWORD_FILE var will cause the app to use the contents of the referenced file as the connection password.


# Docker Compose

It is a tool that was developed to help define and share multi-container applications. With Docker Compose, we can create a YAML file to define the services and with a single command run or tear it all down.

<br>

### Run an application with Docker Compose

<br>

Once you created the ```docker-compose.yaml``` file in the root of your repository you have to type ```docker-compose up -d``` and now all the app should be running.

<details><summary> Docker compose file example. </summary>
<p>

```yaml
version: "3.7"

services:
  app:
    image: node:12-alpine
    command: sh -c "yarn install && yarn run dev"
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment: 
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:

```

</p>
</details>


If you have a look in Docker Dashboard you'll notice there is a project.
By default the project name is the name of the directory of the docker-compose.yaml file, and Docker Compose use the project to group the containers defined there.

The names of each container are also a little more descriptive, as they follow the pattern of ```<project-name>_<service-name>_<replica-number>```.

![Composer](https://github.com/YOSSHUA/Docker/blob/main/Images/composer.PNG?raw=true)

By default, Docker Compose creates a network for the containers and also creates volumes if they don't exist.

<br>

### Stop an application from Docker Compose

<br>

You just have to run the commad ```docker-compose down```. The containers will stop and the network will be removed. By default, named volumes in your compose file are NOT removed. If you want to remove the volumes, you will need to add the --volumes flag.


<br>

# References:

Getting started [tutorial](https://github.com/docker/getting-started).

Docker [documentation](https://www.docker.com/resources/what-container).

